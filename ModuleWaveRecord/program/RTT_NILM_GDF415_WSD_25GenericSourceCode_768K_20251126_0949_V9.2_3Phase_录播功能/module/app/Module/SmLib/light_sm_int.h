
#ifndef LIGHT_SM_INT_H
#define LIGHT_SM_INT_H

#if(!WIN32)
#include <string.h>
#include <stdint.h>
#include <stdlib.h>
#endif
//#define _DEBUG

/********** Global function prototypes ('extern') *****************************/


/********** Local pre-processor symbols/macros ('#define') ********************/

// SM4
#if 1
#define SM4CROL(uval, bits) ((uval << bits) | (uval >> (0x20 - bits)))
#define SM4CROR(uval, bits) ((uval >> bits) | (uval << (0x20 - bits)))
	
#define PAD_BUF_BYTE    64

#define RAND_BYTE_LEN   8
#define RAND_INT_LEN    2

#define RAND_CAT_LEN    (2*RAND_BYTE_LEN)
#define RAND_RET_LEN    (3*RAND_BYTE_LEN)

#define ALL_RAN_BYTES     RAND_RET_LEN
#endif
	
// SM3
#if 1
#define FF0(x,y,z) ( (x) ^ (y) ^ (z)) 
#define FF1(x,y,z) (((x) & (y)) | ( (x) & (z)) | ( (y) & (z)))

#define GG0(x,y,z) ( (x) ^ (y) ^ (z)) 
#define GG1(x,y,z) (((x) & (y)) | ( (~(x)) & (z)) )

//#define  SHL(x,n) (((x) & 0xFFFFFFFF) << (n))
//#define ROTL(x,n) (SHL((x),n) | ((x) >> (32 - n)))
#define  SHL(x,n) ((uint32_t)(x) << ((n)&0x1F))
#define  SHR(x,n) ((uint32_t)(x) >> (32 - ((n)&0x1F)) )
#define ROTL(x,n) ( SHL(x,n) | SHR(x,n) )

#define P0(x) ((x) ^  ROTL((x),9) ^ ROTL((x),17)) 
#define P1(x) ((x) ^  ROTL((x),15) ^ ROTL((x),23))
#endif

#define MODE_KEY    0x00
#define MODE_LK     0x01

/********** Global variable definitions (declared in header file with 'extern') ****/

/********** Local type definitions ('typedef') ********************************/

#if 1

#define FLASH_SET_DATA(i, len, arr, ret) \
for(i = 0; i < len; i++) { \
    if(Ok == callback_flash_writeWord(addr + 4 * i, arr[i])) { \
        if(callback_flash_getWord(addr, i) != arr[i]) \
        { \
            return ret; \
        } \
    } \
}

#define FLASH_GET_DATA(i, len, arr) \
for(i = 0; i < len; i++) { \
    arr[i] = callback_flash_getWord(addr, i); \
}
#endif

/********** Local variable definitions ('static') *****************************/
#define HIGH_PERFORM
#if 1

#ifdef HIGH_PERFORM
static const uint32_t L3Table[256] =
        {0xd55b5b8e, 0x924242d0, 0xeaa7a74d, 0xfdfbfb06, 0xcf3333fc, 0xe2878765, 0x3df4f4c9, 0xb5dede6b,
         0x1658584e, 0xb4dada6e, 0x14505044, 0xc10b0bca, 0x28a0a088, 0xf8efef17, 0x2cb0b09c, 0x05141411,
         0x2bacac87, 0x669d9dfb, 0x986a6af2, 0x77d9d9ae, 0x2aa8a882, 0xbcfafa46, 0x04101014, 0xc00f0fcf,
         0xa8aaaa02, 0x45111154, 0x134c4c5f, 0x269898be, 0x4825256d, 0x841a1a9e, 0x0618181e, 0x9b6666fd,
         0x9e7272ec, 0x4309094a, 0x51414110, 0xf7d3d324, 0x934646d5, 0xecbfbf53, 0x9a6262f8, 0x7be9e992,
         0x33ccccff, 0x55515104, 0x0b2c2c27, 0x420d0d4f, 0xeeb7b759, 0xcc3f3ff3, 0xaeb2b21c, 0x638989ea,
         0xe7939374, 0xb1cece7f, 0x1c70706c, 0xaba6a60d, 0xca2727ed, 0x08202028, 0xeba3a348, 0x975656c1,
         0x82020280, 0xdc7f7fa3, 0x965252c4, 0xf9ebeb12, 0x74d5d5a1, 0x8d3e3eb3, 0x3ffcfcc3, 0xa49a9a3e,
         0x461d1d5b, 0x071c1c1b, 0xa59e9e3b, 0xfff3f30c, 0xf0cfcf3f, 0x72cdcdbf, 0x175c5c4b, 0xb8eaea52,
         0x810e0e8f, 0x5865653d, 0x3cf0f0cc, 0x1964647d, 0xe59b9b7e, 0x87161691, 0x4e3d3d73, 0xaaa2a208,
         0x69a1a1c8, 0x6aadadc7, 0x83060685, 0xb0caca7a, 0x70c5c5b5, 0x659191f4, 0xd96b6bb2, 0x892e2ea7,
         0xfbe3e318, 0xe8afaf47, 0x0f3c3c33, 0x4a2d2d67, 0x71c1c1b0, 0x5759590e, 0x9f7676e9, 0x35d4d4e1,
         0x1e787866, 0x249090b4, 0x0e383836, 0x5f797926, 0x628d8def, 0x59616138, 0xd2474795, 0xa08a8a2a,
         0x259494b1, 0x228888aa, 0x7df1f18c, 0x3bececd7, 0x01040405, 0x218484a5, 0x79e1e198, 0x851e1e9b,
         0xd7535384, 0x00000000, 0x4719195e, 0x565d5d0b, 0x9d7e7ee3, 0xd04f4f9f, 0x279c9cbb, 0x5349491a,
         0x4d31317c, 0x36d8d8ee, 0x0208080a, 0xe49f9f7b, 0xa2828220, 0xc71313d4, 0xcb2323e8, 0x9c7a7ae6,
         0xe9abab42, 0xbdfefe43, 0x882a2aa2, 0xd14b4b9a, 0x41010140, 0xc41f1fdb, 0x38e0e0d8, 0xb7d6d661,
         0xa18e8e2f, 0xf4dfdf2b, 0xf1cbcb3a, 0xcd3b3bf6, 0xfae7e71d, 0x608585e5, 0x15545441, 0xa3868625,
         0xe3838360, 0xacbaba16, 0x5c757529, 0xa6929234, 0x996e6ef7, 0x34d0d0e4, 0x1a686872, 0x54555501,
         0xafb6b619, 0x914e4edf, 0x32c8c8fa, 0x30c0c0f0, 0xf6d7d721, 0x8e3232bc, 0xb3c6c675, 0xe08f8f6f,
         0x1d747469, 0xf5dbdb2e, 0xe18b8b6a, 0x2eb8b896, 0x800a0a8a, 0x679999fe, 0xc92b2be2, 0x618181e0,
         0xc30303c0, 0x29a4a48d, 0x238c8caf, 0xa9aeae07, 0x0d343439, 0x524d4d1f, 0x4f393976, 0x6ebdbdd3,
         0xd6575781, 0xd86f6fb7, 0x37dcdceb, 0x44151551, 0xdd7b7ba6, 0xfef7f709, 0x8c3a3ab6, 0x2fbcbc93,
         0x030c0c0f, 0xfcffff03, 0x6ba9a9c2, 0x73c9c9ba, 0x6cb5b5d9, 0x6db1b1dc, 0x5a6d6d37, 0x50454515,
         0x8f3636b9, 0x1b6c6c77, 0xadbebe13, 0x904a4ada, 0xb9eeee57, 0xde7777a9, 0xbef2f24c, 0x7efdfd83,
         0x11444455, 0xda6767bd, 0x5d71712c, 0x40050545, 0x1f7c7c63, 0x10404050, 0x5b696932, 0xdb6363b8,
         0x0a282822, 0xc20707c5, 0x31c4c4f5, 0x8a2222a8, 0xa7969631, 0xce3737f9, 0x7aeded97, 0xbff6f649,
         0x2db4b499, 0x75d1d1a4, 0xd3434390, 0x1248485a, 0xbae2e258, 0xe6979771, 0xb6d2d264, 0xb2c2c270,
         0x8b2626ad, 0x68a5a5cd, 0x955e5ecb, 0x4b292962, 0x0c30303c, 0x945a5ace, 0x76ddddab, 0x7ff9f986,
         0x649595f1, 0xbbe6e65d, 0xf2c7c735, 0x0924242d, 0xc61717d1, 0x6fb9b9d6, 0xc51b1bde, 0x86121294,
         0x18606078, 0xf3c3c330, 0x7cf5f589, 0xefb3b35c, 0x3ae8e8d2, 0xdf7373ac, 0x4c353579, 0x208080a0,
         0x78e5e59d, 0xedbbbb56, 0x5e7d7d23, 0x3ef8f8c6, 0xd45f5f8b, 0xc82f2fe7, 0x39e4e4dd, 0x49212168};
#endif

static const uint32_t FK[4] = {0xa3b1bac6,0x56aa3350,0x677d9197,0xb27022dc};
static const uint32_t CK[32] = {
0x00070e15,0x1c232a31,0x383f464d,0x545b6269,
0x70777e85,0x8c939aa1,0xa8afb6bd,0xc4cbd2d9,
0xe0e7eef5,0xfc030a11,0x181f262d,0x343b4249,
0x50575e65,0x6c737a81,0x888f969d,0xa4abb2b9,
0xc0c7ced5,0xdce3eaf1,0xf8ff060d,0x141b2229,
0x30373e45,0x4c535a61,0x686f767d,0x848b9299,
0xa0a7aeb5,0xbcc3cad1,0xd8dfe6ed,0xf4fb0209,
0x10171e25,0x2c333a41,0x484f565d,0x646b7279
};

static const uint8_t SboxTable[256] = {
0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05,
0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99,
0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62,
0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6,
0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8,
0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35,
0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87,
0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e,
0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1,
0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3,
0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f,
0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51,
0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8,
0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0,
0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84,
0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48
};

static const uint8_t g_SM3Pad[64] = {
 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

static uint32_t g_SM3_BUF[68];

static const uint8_t cmpEnc[3] = {0x01,0x0A,0x01};
static const uint8_t cmpDec[3] = {0x01,0x0B,0x01};
static const uint8_t cmpAuth[3] = {0x01,0x0C,0x01};
#endif

/********** Local pre-processor symbols/macros ('#define') ********************/

#ifndef GET_ULONG_BE
#define GET_ULONG_BE(n,b,i)                             \
{                                                       \
    (n) = ( (uint32_t) (b)[(i)    ] << 24 )        \
        | ( (uint32_t) (b)[(i) + 1] << 16 )        \
        | ( (uint32_t) (b)[(i) + 2] <<  8 )        \
        | ( (uint32_t) (b)[(i) + 3]       );       \
}
#endif

#ifndef PUT_ULONG_BE
#define PUT_ULONG_BE(n,b,i)                             \
{                                                       \
    (b)[(i)    ] = (uint8_t) ( (n) >> 24 );       \
    (b)[(i) + 1] = (uint8_t) ( (n) >> 16 );       \
    (b)[(i) + 2] = (uint8_t) ( (n) >>  8 );       \
    (b)[(i) + 3] = (uint8_t) ( (n)       );       \
}
#endif

#if 1

#define PAD_ID(pbuf,devid,idlen)	{\
	left = 16;									\
	while(left >= idlen) {			\
		memcpy(pbuf, devid, idlen);	\
		pbuf += idlen;						\
		left -= idlen;						\
	}	\
	if(left!=0) {								\
		memcpy(pbuf, devid, left);	\
	}	\
}
#define GET_STAT_LKEY(stat,LKey) {\
    uint8_t idBuf[16], left; \
    uint8_t *pbuf = idBuf;   \
    uint8_t devid[16];       \
    uint32_t idlen = ID_LEN;  \
    stat = getStatus(devid, idlen); \
    PAD_ID(pbuf,devid,idlen);   \
    getDecKey(MODE_LK, idBuf, LKey);    \
}

#define SWAP(var,a,b) {var=a; a=b; b=var;}
#define FLASH_GET_KEY(kbuf, keyadd) callback_flash_getWords(keyadd, 4, kbuf)
#define FLASH_GET_IV_ENC(tbuf, ivadd) FLASH_GET_KEY(tbuf, ivadd)
//SWAP(tmp, tbuf[0], tbuf[3]);
//SWAP(tmp, tbuf[1], tbuf[2]);

//#define FLASH_GET_IV_ENC(tmp, tbuf, ivadd) {\
//callback_flash_getWords(ivadd, 4, tbuf); \
//SWAP(tmp, tbuf[0], tbuf[3]); \
//SWAP(tmp, tbuf[1], tbuf[2]); \
//}

#define FLASH_GET_IV_DEC(bbuf, ivadd) FLASH_GET_KEY(bbuf, ivadd)

#endif

/********** Local function prototypes ('static') ******************************/
static uint32_t SM4CalciRK(uint32_t x);
static uint32_t SM4EnyT(uint32_t x);
static void sm3_simple_blk( uint8_t *input, uint32_t ilen, uint8_t output[32] );

/**Core**/
static uint32_t SM4CalciRK(uint32_t a) {
  uint32_t b = 0;
  //uint32_t rk = 0;
  uint8_t a0 = (uint8_t)a;
  uint8_t a1;
  uint8_t a2;
  uint8_t a3;
	
	a >>= 8;
	a1 = (uint8_t)a;
	a >>= 8;
	a2 = (uint8_t)a;
	a3 = (uint8_t)(a>>8);

	b  = SboxTable[a3];
	b <<= 8;
	b |= SboxTable[a2];
	b <<= 8;
	b |= SboxTable[a1];
	b = (b<<8) | SboxTable[a0];

  //rk = b^(SM4CROL(b, 13))^(SM4CROL(b, 23));
		
  return b^(SM4CROL(b, 13))^(SM4CROR(b, 9));
}
#ifdef HIGH_PERFORM
static uint32_t SM4EnyT(uint32_t x) {
    uint32_t t;

    t = L3Table[(uint8_t) x];
    x >>= 8u;
    t ^= SM4CROL(L3Table[(uint8_t) x], 8u);
    x >>= 8u;
    t ^= SM4CROL(L3Table[(uint8_t) x], 16u);

    return t ^ SM4CROL(L3Table[(uint8_t) (x >> 8u)], 24u);
}

#else
static uint32_t SM4EnyT(uint32_t a) {
  uint32_t b = 0;
  uint32_t c = 0;
  uint8_t a0 = (uint8_t)a;
  uint8_t a1;
  uint8_t a2;
  uint8_t a3;
	
	a >>= 8;
	a1 = (uint8_t)a;
	a >>= 8;
	a2 = (uint8_t)a;
	a3 = (uint8_t)(a>>8);

	b  = SboxTable[a3];
	b <<= 8;
	b |= SboxTable[a2];
	b <<= 8;
	b |= SboxTable[a1];
	b = (b<<8) | SboxTable[a0];
	
	c = SM4CROL(b, 2);
	b ^= (SM4CROR(b, 8));
	//c ^= b^ SM4CROR(b, 14);

  return c^ b^ SM4CROR(b, 14);
}
#endif

#endif
